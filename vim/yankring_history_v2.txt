# Use vim keybindings in copy modesetw -g mode-keys vi# Setup 'v' to begin selection as in Vimbind-key -t vi-copy v begin-selectionbind-key -t vi-copy y copy-pipe "reattach-to-user-namespace pbcopy"# Update default binding of `Enter` to also use copy-pipeunbind -t vi-copy Enterbind-key -t vi-copy Enter copy-pipe "reattach-to-user-namespace pbcopy",v
 ,v
,V
(end points of elements),v
        ! Load local node coordinates, global node #'s,V
! XL(i), YL(i), JL(i),v
Assemble Influence Coefficient Matrices,v
!===============================================================================!       Assemble Influence Coefficient Matrices!===============================================================================,V
n,v
d,v
                A(i,JL(i)) = A(i,JL(j)) + phi(j)*dGidn*(ds/2d0)*Wk,V
x,v
;,v
            / ,V
 / (ds,v
dist,v
singularity,v
    ,V
! Loop over elements,v
! Loop over nodes,v
            xs = xl(1)*phi1 + xl(2)*phi2,V
            phi1 = (1d0 - xi(k))/2d0,V
            z = xi(k),V
:,v
            break;,V
print *, PI,V
real(8), parameter :: PI = 4*atan(1d0),V
PARAMETERS:,v
! use msolve,V
! use fea_util,V
use msolve,V
use fea_util,V
use ,v
#,v
Calculate [A^-1],v
-,v
into,v
    !---------------------,V
        !---------------------,V
    !print *,'Done.'    !print *,'',V
!   nrow = size(Ain, 1)!   ncol = size(Ain, 2)!   dir = './output/'!   inquire(file=dir, exist=yn)                         ! check if output directory exists!   if (.not.yn) then                                   ! if it doesn't exist!       call system('mkdir '//trim(dir))                ! create it!   endif!   outfile = trim(dir)//trim(outfile)                  ! files will be moved in main script,V
! real(8), dimension(3,3) :: A, Ainv! ! A = reshape((/1,2,3,4,5,6,7,8,9\),(/3,3/))! A = reshape((/1,2,3,4,5,6,7,8,9/), (/3,3/))! call INVERSE(A,Ainv)!! print *, "A = "! call PRINTREAL( A, 3, 3, 0 )! print *, "Ainv = "! call PRINTREAL( Ainv, 3, 3, 0 ),V
],v
[,v
/,v
(,v
|,v
=,v
" Map \M to make in backgroundnnoremap <Leader>M :silent! make | redraw!,V
EYE(3,3),v
print *, "A = ",V
call PRINTREAL( A, 5, 5, 0 ),V
size_flag,v
ncol,v
nrow,v
i,v
PRINTREAL( Ain, nrow, ncol, size_flag ),v
    !=======================================================================,V
    !---------------------,V
    ,V
!=======================================================================,V
end module mathops,V
    end subroutine,V
    print *, 'DGETRI INFO: ', INFO,V
    call DGETRI( nrow, Ainv, nrow, IPIV, WORK, nrow, INFO )     ,V
    Ainv = LR                       ! destructive inversion using factorization,V
    WORK = 0d0; Ainv = 0d0,V
    !--------------------------------------------------------------- Calculate [A^-1],V
    print *, 'DGETRF INFO: ', INFO  ! If INFO > 0, matrix is singular,V
    call DGETRF( nrow, nrow, LR, nrow, IPIV, INFO ),V
    LR = A,V
    ! Factorize Aglobal_full into [L][R] destructively,V
    IPIV = 0; WORK = 0d0; LR = 0d0;,V
    allocate( IPIV(nrow), WORK(nrow), LR(nrow, nrow) ),V
    nrow = size(A,1),V
    ! Allocate arrays,V
    real(8), dimension(:,:) :: A, Ainv,V
    real(8), dimension(:,:), allocatable :: LR       ! LU decomposition of A,V
    real(8),   dimension(:), allocatable :: WORK     ! Working space for inversion,V
    integer,  dimension(:), allocatable :: IPIV     ! Pivot indices from DGETRF for lapack solver,V
    integer nrow, INFO,V
    IMPLICIT NONE,V
    ! INVERSE returns the inverse of full matrix [A] in [Ainv] using LAPACK subroutines,V
    subroutine INVERSE( A, Ainv ),V
    end function eye,V
    RETURN,V
    end function RMS,V
    RMS = Vsqrmean**0.5,V
    ! Take sqrt of mean,V
    Vsqrmean = mean(Vsqr),V
    ! Take mean of squared entries,V
    Vsqr = V**2,V
    ! Square all entries in array,V
    Vsqr = 0d0; Vsqrmean = 0d0,V
    allocate( Vsqr(N) ),V
    N = size(V,1),V
    real(8), dimension(:), allocatable :: Vsqr,V
    real(8), dimension(:) :: V,V
    real(8) Vsqrmean,V
    integer N,V
