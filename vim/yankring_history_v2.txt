! call PRINTREAL( xi(1:M/2), 1,M/2,0),v
# Force tmux to use 256 colors (get solarized right),v
 git://github.com/AndrewRadev/linediff.vim.git,v
,V
cs50(){  if [ $# -gt 0 ]; then      cd ~/Documents/School/cs50/labs/lab$1/  else      cd ~/Documents/School/cs50  fi},V
fi,V
if [[ "$OSTYPE" == "darwin"* ]]; then,V
wE(n,i+1) = wE(n,i) + h*ratef(wE(n,i),t(i));,v
, halfxi, halfWk,v
,,v
 halfxi(M/2), halfWk(M/2),v
 halfxi(:) = 0d0; halfWk(:) = 0d0;,v
norm2(abs( xi(1:M/2) + xi(M:(M/2+1):-1) )),v
,V
halfWk,v
Wk(1:M/2) - Wk(M:(M/2+1):-1) ,v
halfWk =  ,v
halfxi,v
xi(1:M/2) + xi(M:(M/2+1):-1) ,v
halfxi = ,v
2,v
call PRINTREAL( xi(1:2), 1,2,0),V
 ,v
/,v
(,v
),v
testxi, testWk ,v
! call PRINTREAL( (/ testxi, testWk /), 1,2,0),V
! Check points are antisymmetric and weights are symmetric,V
 Wk(1:M/2) - Wk(M:(M/2+1)) ,v
 xi(1:M/2) + xi(M:(M/2+1)) ,v
%,V
:,v
(M/2+1),v
  ,1
, testxi, testWk,v
), normWk(,v
, normxi(M,v
normWk,v
testxi,v
norm,v
normxi,v
norm2(abs(Wk(1:M/2) - Wk((M/2+1):M))) /),v
norm2(abs(xi(1:M/2) + xi(M:(M/2+1)))),v
call PRINTREAL( abs(xi(1)) - abs(xi(M/2)), 1, 1, 0),V
call PRINTREAL( abs(xi(1:M/2)), ,v
call PRINTREAL( abs(xi(1:M/2)), ,V
call PRINTREAL(,v
call PRINTREAL(,V
M:,v
x,v
-,v
(x(1:M/2) + x(M:(M/2+1))),v
x(M:(M/2+1))),,v
answers,v
!===============================================================================,v
!===============================================================================,V
                     ,v
M,v
, i,v
 = 16,v
:: ,v
, parameter ,v
! run program using: ./run sor theta r OR ./run sor theta r,V
method,v
if (i.lt.1) then						! set defaults,V
	method   = 'sor'					! iterative solution method	th	     = 0.6d0	rin      = 10d0	fileid   = 'midterm'							else if (i.lt.2) then					! read method from command line,V
! Get N from command line argument! run program using: ./run sor theta r OR ./run sor theta ri = IARGC()			! number of command line argumentsif (i.lt.1) then						! set defaults	method   = 'sor'					! iterative solution method	th	     = 0.6d0	rin      = 10d0	fileid   = 'midterm'							else if (i.lt.2) then					! read method from command line	call GETARG(1, method),v
! Get N from command line argument! run program using: ./run sor theta r OR ./run sor theta ri = IARGC()			! number of command line argumentsif (i.lt.1) then						! set defaults	method   = 'sor'					! iterative solution method	th	     = 0.6d0	rin      = 10d0	fileid   = 'midterm'							else if (i.lt.2) then					! read method from command line	call GETARG(1, method),V
SRCMODUTIL = $(MODUTILDIR)/lib_util.f95,v
SRCMODUTIL = $(MODUTILDIR)/lib_util.f95,V
OBJ    = test_lgwt.o,v
OBJ    = test_lgwt.o,V
-5,v
CC = gfortran-5,V
,v
%,v
%==============================================================================% LGWT computes N Gauss point locations and weights between points a and b,V
%==============================================================================% LGWT computes N Gauss point locations and weights between points a and b%% INPUTS:%   N     = number of points%   a,b   = lower and upper bounds of interval, default [-1,1]%   x     = Gauss point locations (symmetric about 0)%   w     = weights %% INTERNAL VARIABLES:%   L     = Legendre-Gauss Vandermonde Matrix%   Lp    = derivative of L%% Adapted from lgwt.m by Greg von Winckel - 02/25/2004%==============================================================================,V
#endif,V
LOG(trim(msg)),V
write(msg,'(A,I3)')  'Iterations used: ',iter,V
#ifdef LOGSTATUS,V
0,v
.,v
.0,v
.0      ,v
do,v
break,v
        exit,V
        print *, error,V
LOG,v
.EQ. ,v
maxval,v
dble,v
&,v
.EQ.,v
.OR.,v
.GT.,v
do ,v
